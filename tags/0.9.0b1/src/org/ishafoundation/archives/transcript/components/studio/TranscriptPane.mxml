<?xml version="1.0" encoding="utf-8"?>

<!--

   Transcript Markups Editor: An XML based application that allows users to define 
   and store contextual metadata for contiguous sections within a text document. 

   Copyright 2008 Mark Carter, Swami Kevala

   This file is part of Transcript Markups Editor.

   Transcript Markups Editor is free software: you can redistribute it and/or modify it 
   under the terms of the GNU General Public License as  published by the Free Software 
   Foundation, either version 3 of the License, or (at your option) any later version.

   Transcript Markups Editor is distributed in the hope that it will be useful, but 
   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along with 
   Transcript Markups Editor. If not, see http://www.gnu.org/licenses/.

-->

<mx:HDividedBox xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:markupNS="org.ishafoundation.archives.transcript.components.studio.markup.*" xmlns:textNS="org.ishafoundation.archives.transcript.components.studio.text.*" horizontalGap="{Utils.DIVIDER_SIZE}" resizeToContent="true" creationComplete="init()">
	<mx:Script>
    <![CDATA[
    	import org.ishafoundation.archives.transcript.components.studio.text.GeneralNodePropertiesPane;
    	import mx.events.PropertyChangeEvent;
    	import mx.binding.utils.ChangeWatcher;
    	import org.ishafoundation.archives.transcript.components.studio.text.AbstractEditDialog;
    	import name.carter.mark.flex.project.mdoc.MNode;
    	import name.carter.mark.flex.project.mdoc.MSuperNodeProperties;
    	import org.ishafoundation.archives.transcript.components.studio.markup.MarkupPropertiesPane;
    	import name.carter.mark.flex.project.mdoc.MSegmentSubset;
    	import name.carter.mark.flex.project.mdoc.MSegmentRange;
    	import name.carter.mark.flex.project.mdoc.MContentRange;
    	import name.carter.mark.flex.project.mdoc.MSuperNode;
    	import name.carter.mark.flex.project.mdoc.MSuperContent;
    	import name.carter.mark.flex.project.mdoc.MSuperSegment;
    	import name.carter.mark.flex.project.mdoc.MContent;
    	import name.carter.mark.flex.project.mdoc.MSegment;
    	import name.carter.mark.flex.project.mdoc.TaggableMNode;
    	import name.carter.mark.flex.util.Utils;
    	import org.ishafoundation.archives.transcript.components.studio.text.EditSegmentSubsetDialog;
    	import mx.utils.StringUtil;
    	import mx.managers.PopUpManager;
    	import org.ishafoundation.archives.transcript.components.studio.text.EditSegmentDialog;
    	import org.ishafoundation.archives.transcript.components.studio.text.TranscriptTextArea;
    	import org.ishafoundation.archives.transcript.components.studio.markup.MarkupsTree;
		import flash.events.Event;
		
		import mx.containers.HDividedBox;
		import mx.controls.Alert;
		
		import org.ishafoundation.archives.transcript.db.*;
		import org.ishafoundation.archives.transcript.model.*;
		import org.ishafoundation.archives.transcript.util.*;
		
		public static const MAX_START_TEXT_LENGTH:int = 140;
		public static const MAX_COMMENT_LENGTH:int = 140;
		
		[Bindable]
		public var referenceMgr:ReferenceManager;
	    private var _transcript:Transcript;
	    
		private function init():void {
			var thisObj:TranscriptPane = this;
			// note - cannot bind to "selectedMarkup" because not bindable
			markupsPane.markupsTree.addEventListener(MarkupsTree.MARKUP_SELECTION_CHANGE_EVENT, function(evt:Event):void {
				var markup:MSuperNode = markupsPane.selectedMarkup;
				if (markup != null && ttSelection != null && ttSelection.toSuperNode() != null && ttSelection.toSuperNode() != markup) {
					// don't allow different tree selection to text markup selection
					transcriptTextArea.ttSelection = null;
				}
			});
			this.markupsPane.markupsTree.addEventListener(MouseEvent.DOUBLE_CLICK, function(evt:Event):void {
				if (markupsPane.selectedMarkup != null) {
					transcriptTextArea.selectMarkup(markupsPane.selectedMarkup);
					transcriptTextAreaSelectionChange(null);
				}
			});
			this.transcriptTextArea.addEventListener(TranscriptTextArea.SELECTION_CHANGE_EVENT, transcriptTextAreaSelectionChange);
			this.markupsPane.markupPropertiesPane.addEventListener(MarkupPropertiesPane.MARKUP_PROPERTIES_CHANGE_EVENT, function(evt:Event):void {
				// TODO - this selectedMarkup is sometimes null when it shouldnt be
				if (markupsPane.selectedMarkup == null) {
					throw new Error("Could not handle markup properties change because markupsPane.selectedMarkup is null");
				}
				markupPropertiesChangeHandler(markupsPane.selectedMarkup);
			});     		
			this.markupsPane.markupPropertiesPane.addEventListener(MarkupPropertiesPane.MARKUP_REMOVE_EVENT, function(evt:Event):void {
				removeMarkup();
			});     		
			this.markupsPane.generalNodePropertiesPane.addEventListener(GeneralNodePropertiesPane.GENERAL_NODE_PROPERTIES_CHANGE_EVENT, function(evt:Event):void {
				if (transcriptTextArea.ttSelection == null) {
					trace("WARN: ttSelection is null - probably because the General Properties pane is enabled when it shouldnt be");
					return;
				}
				transcriptTextArea.transcriptTextChangeHandler(transcriptTextArea.ttSelection.selectedObj);
			});     		
		}
		
		public function set transcript(transcript:Transcript):void {
			this._transcript = transcript;
		}
		
		[Bindable]
		public function get transcript():Transcript {
			return this._transcript;
		}
		
		private function loadReferenceBeforeContinuing(nextFunction:Function):void {
			referenceMgr.loadReferences(nextFunction, function(msg:String):void {
				trace("Could not load references file but continuing anyway: " + msg);
				nextFunction();
			});
		}
		
		private function markupPropertiesChangeHandler(markup:MSuperNode):void {
			this.markupsPane.markupPropertiesChangeHandler(markup);
			this.transcriptTextArea.markupPropertiesChangeHandler(markup);
		}
		
		private function get ttSelection():TranscriptTextSelection {
			return this.transcriptTextArea.ttSelection;
		}
		
		internal function nudgeUp():void {
			ttSelection.nudgeUp();
			this.markupsPane.ttSelectionChangeHandler(transcriptTextArea.ttSelection);
			this.transcriptTextArea.transcriptTextChangeHandler(transcriptTextArea.ttSelection.selectedObj);
		}

		internal function nudgeDown():void {
			ttSelection.nudgeDown();
			this.markupsPane.ttSelectionChangeHandler(transcriptTextArea.ttSelection);
			this.transcriptTextArea.transcriptTextChangeHandler(transcriptTextArea.ttSelection.selectedObj);
		}

		internal function markupText():void {
			var ttSelection:TranscriptTextSelection = transcriptTextArea.ttSelection;
			var markup:MSuperNode = ttSelection.markup();
			this.markupsPane.markupHierarchyChangeHandler(markup);
			callLater(function():void {
				markupsPane.selectedMarkup = markup;
			});
			this.transcriptTextArea.markupHierarchyChangeHandler(markup);
			callLater(transcriptTextAreaSelectionChange, [null]);
		}

		/**
		 * Returns the parent.
		 */
		public function removeMarkup():void {
			var markup:MSuperNode = markupsPane.selectedMarkup;
			markup.remove();
			this.markupsPane.markupHierarchyChangeHandler(markup);
			this.transcriptTextArea.markupHierarchyChangeHandler(markup);
		}

		internal function editText():void {
			var allowMultipleSegments:Boolean = this.ttSelection.toSegmentRange() != null;
			if (this.ttSelection.toSegment() != null) {
				// check if the segment is also an inline
				var segment:MSegment = this.ttSelection.toSegment();
				if (segment.toContentRange().toSuperContent() != null) {
					// don't allow the contents of an inline to go multi-segment
					allowMultipleSegments = false;
				}
			}
			var popup:AbstractEditDialog = allowMultipleSegments ? new EditSegmentDialog() : new EditSegmentSubsetDialog();
			popup.addEventListener(EditSegmentDialog.OK_CLICKED, function(evt:Event):void{
				var affectedObj:Object = ttSelection.editText(popup.texts);
				if (affectedObj == null) {
					Alert.show("Text has not changed");
					return;					
				}
				markupsPane.ttSelectionChangeHandler(new TranscriptTextSelection(affectedObj));
				transcriptTextArea.transcriptTextChangeHandler(affectedObj);
			});
			PopUpManager.addPopUp(popup, this, true);
			popup.texts = [ttSelection.getText()];
		}
		
		internal function mergeSegmentRange():void {
			var segment:MSegment = this.ttSelection.merge();
			this.markupsPane.ttSelectionChangeHandler(new TranscriptTextSelection(segment));
			this.transcriptTextArea.transcriptTextChangeHandler(segment);
		}
		
		internal function deleteText():void {
			transcriptTextArea.ttSelection.deleteText();
			this.markupsPane.ttSelectionChangeHandler(null);
			this.transcriptTextArea.transcriptTextChangeHandler();
		}

		private function markupsTreeDoubleClicked(event:Event):void {
			if (this.markupsPane.selectedMarkup != null) {
				this.transcriptTextArea.selectMarkup(this.markupsPane.selectedMarkup);
			}
		}
	
		private function transcriptTextAreaSelectionChange(evt:Event):void {
			markupsPane.ttSelectionChangeHandler(transcriptTextArea.ttSelection);
		}		
	]]>
	</mx:Script>
	<markupNS:MarkupsPane id="markupsPane" width="25%" minWidth="355" height="100%" verticalGap="{Utils.DIVIDER_SIZE}" transcript="{this.transcript}"/>
	<textNS:TranscriptTextArea id="transcriptTextArea" width="75%" height="100%" referenceMgr="{this.referenceMgr}" transcript="{this.transcript}"/>
</mx:HDividedBox>
