<!--
   Transcript Studio for Isha Foundation: An XML based application that allows users to define 
   and store contextual metadata for contiguous sections within a text document. 

   Copyright 2008 Mark Carter, Swami Kevala

   This file is part of Transcript Studio for Isha Foundation.

   Transcript Studio for Isha Foundation is free software: you can redistribute it and/or modify it 
   under the terms of the GNU General Public License as  published by the Free Software 
   Foundation, either version 3 of the License, or (at your option) any later version.

   Transcript Studio for Isha Foundation is distributed in the hope that it will be useful, but 
   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along with 
   Transcript Studio for Isha Foundation. If not, see http://www.gnu.org/licenses/.
-->
<mx:HDividedBox xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:markupNS="org.ishafoundation.archives.transcript.components.studio.markup.*" xmlns:textNS="org.ishafoundation.archives.transcript.components.studio.text.*" horizontalGap="{Utils.DIVIDER_SIZE}" resizeToContent="true" creationComplete="init()">
	<mx:Script>
    <![CDATA[
    	import org.ishafoundation.archives.transcript.components.studio.text.GeneralNodePropertiesPane;
    	import mx.events.PropertyChangeEvent;
    	import mx.binding.utils.ChangeWatcher;
    	import org.ishafoundation.archives.transcript.components.studio.text.AbstractEditDialog;
    	import name.carter.mark.flex.project.mdoc.MNode;
    	import name.carter.mark.flex.project.mdoc.MSuperNodeProperties;
    	import org.ishafoundation.archives.transcript.components.studio.markup.MarkupPropertiesPane;
    	import name.carter.mark.flex.project.mdoc.MSegmentSubset;
    	import name.carter.mark.flex.project.mdoc.MSegmentRange;
    	import name.carter.mark.flex.project.mdoc.MContentRange;
    	import name.carter.mark.flex.project.mdoc.MSuperNode;
    	import name.carter.mark.flex.project.mdoc.MSuperContent;
    	import name.carter.mark.flex.project.mdoc.MSuperSegment;
    	import name.carter.mark.flex.project.mdoc.MContent;
    	import name.carter.mark.flex.project.mdoc.MSegment;
    	import name.carter.mark.flex.project.mdoc.TaggableMNode;
    	import name.carter.mark.flex.util.Utils;
    	import mx.utils.StringUtil;
    	import mx.managers.PopUpManager;
    	import org.ishafoundation.archives.transcript.components.studio.text.TranscriptTextArea;
    	import org.ishafoundation.archives.transcript.components.studio.markup.MarkupsTree;
		import flash.events.Event;
		
		import mx.containers.HDividedBox;
		import mx.controls.Alert;
		
		import org.ishafoundation.archives.transcript.db.*;
		import org.ishafoundation.archives.transcript.model.*;
		import org.ishafoundation.archives.transcript.util.*;
		
		public static const MAX_START_TEXT_LENGTH:int = 140;
		public static const MAX_COMMENT_LENGTH:int = 140;
		
		[Bindable]
		public var referenceMgr:ReferenceManager;
	    private var _transcript:Transcript;
	    
		private function init():void {
			var thisObj:TranscriptPane = this;
			// note - cannot bind to "selectedMarkup" because not bindable
			markupsPane.markupsTree.addEventListener(MarkupsTree.MARKUP_SELECTION_CHANGE_EVENT, function(evt:Event):void {
				var markup:MSuperNode = markupsPane.selectedMarkup;
				if (markup != null && ttSelection != null && ttSelection.toSuperNode() != null && ttSelection.toSuperNode() != markup) {
					// don't allow different tree selection to text markup selection
					textPane.transcriptTextArea.ttSelection = null;
				}
			});
			this.markupsPane.markupsTree.addEventListener(MouseEvent.DOUBLE_CLICK, function(evt:Event):void {
				if (markupsPane.selectedMarkup != null) {
					textPane.transcriptTextArea.selectMarkup(markupsPane.selectedMarkup);
					transcriptTextAreaSelectionChange(null);
				}
			});
			this.textPane.addEventListener(TranscriptTextArea.SELECTION_CHANGE_EVENT, transcriptTextAreaSelectionChange);
			this.markupsPane.markupPropertiesPane.addEventListener(MarkupPropertiesPane.MARKUP_PROPERTIES_CHANGE_EVENT, function(evt:Event):void {
				// TODO - this selectedMarkup is sometimes null when it shouldnt be
				if (markupsPane.selectedMarkup == null) {
					throw new Error("Could not handle markup properties change because markupsPane.selectedMarkup is null");
				}
				markupPropertiesChangeHandler(markupsPane.selectedMarkup);
			});     		
			this.markupsPane.markupPropertiesPane.addEventListener(MarkupPropertiesPane.MARKUP_REMOVE_EVENT, function(evt:Event):void {
				removeMarkup();
			}); 
		}
		
		public function set transcript(transcript:Transcript):void {
			this._transcript = transcript;
		}
		
		[Bindable]
		public function get transcript():Transcript {
			return this._transcript;
		}
		
		private function loadReferenceBeforeContinuing(nextFunction:Function):void {
			referenceMgr.loadReferences(nextFunction, function(msg:String):void {
				trace("Could not load references file but continuing anyway: " + msg);
				nextFunction();
			});
		}
		
		private function markupPropertiesChangeHandler(markup:MSuperNode):void {
			this.markupsPane.markupPropertiesChangeHandler(markup);
			this.textPane.markupPropertiesChangeHandler(markup);
		}
		
		private function get ttSelection():TranscriptTextSelection {
			return this.textPane.ttSelection;
		}
		
		internal function nudgeUp():void {
			ttSelection.nudgeUp();
			this.markupsPane.ttSelectionChangeHandler(textPane.ttSelection);
			this.textPane.transcriptTextChangeHandler(textPane.ttSelection.selectedObj);
		}

		internal function nudgeDown():void {
			ttSelection.nudgeDown();
			this.markupsPane.ttSelectionChangeHandler(textPane.ttSelection);
			this.textPane.transcriptTextChangeHandler(textPane.ttSelection.selectedObj);
		}

		internal function markupText():void {
			var ttSelection:TranscriptTextSelection = textPane.ttSelection;
			var markup:MSuperNode = ttSelection.markup();
			this.markupsPane.markupHierarchyChangeHandler(markup);
			callLater(function():void {
				markupsPane.selectedMarkup = markup;
			});
			this.textPane.markupHierarchyChangeHandler(markup);
			callLater(transcriptTextAreaSelectionChange, [null]);
		}

		/**
		 * Returns the parent.
		 */
		public function removeMarkup():void {
			var markup:MSuperNode = markupsPane.selectedMarkup;
			markup.remove();
			this.markupsPane.markupHierarchyChangeHandler(markup);
			this.textPane.markupHierarchyChangeHandler(markup);
		}

		internal function mergeSegmentRange():void {
			var segment:MSegment = this.ttSelection.merge();
			this.markupsPane.ttSelectionChangeHandler(new TranscriptTextSelection(segment));
			this.textPane.transcriptTextChangeHandler(segment);
		}
		
		internal function deleteText():void {
			textPane.ttSelection.deleteText();
			this.markupsPane.ttSelectionChangeHandler(null);
			this.textPane.transcriptTextChangeHandler();
		}

		private function markupsTreeDoubleClicked(event:Event):void {
			if (this.markupsPane.selectedMarkup != null) {
				this.textPane.selectMarkup(this.markupsPane.selectedMarkup);
			}
		}
	
		private function transcriptTextAreaSelectionChange(evt:Event):void {
			markupsPane.ttSelectionChangeHandler(textPane.ttSelection);
		}		
	]]>
	</mx:Script>
	<markupNS:MarkupsPane id="markupsPane" width="25%" minWidth="355" height="100%" verticalGap="{Utils.DIVIDER_SIZE}" transcript="{this.transcript}"/>
	<textNS:TranscriptTextPane id="textPane" width="75%" minWidth="600" height="100%" verticalGap="{Utils.DIVIDER_SIZE}" referenceMgr="{this.referenceMgr}" transcript="{this.transcript}"/>
</mx:HDividedBox>
